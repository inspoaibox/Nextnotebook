# 暮城笔记 - 项目规格文档

## 项目概述

暮城笔记是一款安全、简洁的本地加密笔记应用，支持桌面端和移动端。采用端到端加密，本地优先的设计理念。

## 技术架构

### 整体架构
```
┌─────────────────────────────────────────┐
│                UI Layer                 │
│            (Electron + React)           │
├─────────────────────────────────────────┤
│              Core Layer                 │
│  ┌─────────────┬─────────────────────┐  │
│  │   Items     │    Sync Engine      │  │
│  │  Manager    │                     │  │
│  ├─────────────┼─────────────────────┤  │
│  │   Crypto    │   Module Registry   │  │
│  │   Engine    │                     │  │
│  └─────────────┴─────────────────────┘  │
├─────────────────────────────────────────┤
│            Platform Layer               │
│  ┌─────────────┬─────────────────────┐  │
│  │   SQLite    │    File System      │  │
│  │  Database   │                     │  │
│  ├─────────────┼─────────────────────┤  │
│  │  Network    │    Security Store   │  │
│  │   Client    │                     │  │
│  └─────────────┴─────────────────────┘  │
└─────────────────────────────────────────┘
```

### 技术栈选择

**桌面端 (Windows 优先)**
- **框架**: Electron 
- **前端**: React + TypeScript
- **状态管理**: Zustand
- **UI组件**: Ant Design / Chakra UI
- **数据库**: SQLite (better-sqlite3)
- **加密**: Node.js crypto module
- **Markdown**: react-markdown + remark/rehype

**移动端 (后续)**
- **框架**: React Native 或 Flutter
- **数据库**: SQLite
- **共享**: Core业务逻辑层

## 数据模型设计

### 统一 Item 模型
所有可同步实体统一为 Item 结构：

```typescript
interface ItemBase {
  id: string;              // UUID
  type: ItemType;          // 'note' | 'folder' | 'tag' | 'resource' | 'todo' | 'vault_entry' | 'diagram'
  created_time: number;    // Unix timestamp
  updated_time: number;    // Unix timestamp  
  deleted_time?: number;   // 软删除时间
  payload: any;            // 业务数据 (JSON)
  content_hash: string;    // SHA-256 hash
  sync_status: SyncStatus; // 'clean' | 'modified' | 'deleted' | 'conflict'
  local_rev: number;       // 本地版本号
  remote_rev?: string;     // 远端版本标识
  encryption_applied: boolean; // 是否加密
  schema_version: number;  // Schema版本
}

enum ItemType {
  NOTE = 'note',
  FOLDER = 'folder', 
  TAG = 'tag',
  RESOURCE = 'resource',
  TODO = 'todo',
  VAULT_ENTRY = 'vault_entry',
  DIAGRAM = 'diagram'
}

enum SyncStatus {
  CLEAN = 'clean',
  MODIFIED = 'modified', 
  DELETED = 'deleted',
  CONFLICT = 'conflict'
}
```

### 具体业务模型

**笔记 (Note)**
```typescript
interface NotePayload {
  title: string;
  content: string;        // Markdown content
  folder_id?: string;
  tag_ids: string[];
  is_pinned: boolean;
  password_protected: boolean;
  password_hash?: string; // 独立密码
  attachments: string[];  // resource_ids
}
```

**文件夹 (Folder)**
```typescript
interface FolderPayload {
  name: string;
  parent_id?: string;
  color?: string;
  icon?: string;
}
```

**标签 (Tag)**
```typescript
interface TagPayload {
  name: string;
  color: string;
}
```

**附件 (Resource)**
```typescript
interface ResourcePayload {
  filename: string;
  mime_type: string;
  size: number;
  file_path: string;      // 本地文件路径
}
```

## 核心功能模块

### 1. Items Manager
负责所有业务对象的CRUD操作

```typescript
class ItemsManager {
  async createItem(type: ItemType, payload: any): Promise<ItemBase>
  async getItem(id: string): Promise<ItemBase | null>
  async updateItem(id: string, payload: any): Promise<ItemBase>
  async deleteItem(id: string): Promise<void>
  async listItems(type?: ItemType, filters?: any): Promise<ItemBase[]>
  async searchItems(query: string): Promise<ItemBase[]>
}
```

### 2. Sync Engine
处理本地与远端的数据同步

```typescript
interface StorageAdapter {
  listChanges(cursor?: string, limit?: number): Promise<ChangeItem[]>
  getItem(id: string): Promise<ItemBase | null>
  putItem(item: ItemBase): Promise<void>
  getResource(id: string): Promise<Buffer>
  putResource(id: string, data: Buffer): Promise<void>
  getRemoteMeta(): Promise<RemoteMeta>
}

class SyncEngine {
  async sync(): Promise<SyncResult>
  async push(): Promise<void>      // 上传本地变更
  async pull(): Promise<void>      // 拉取远端变更  
  async commit(): Promise<void>    // 提交同步状态
}
```

### 3. Crypto Engine
处理端到端加密

```typescript
class CryptoEngine {
  async generateMasterKey(password: string): Promise<string>
  async encryptPayload(payload: any, key: string): Promise<string>
  async decryptPayload(ciphertext: string, key: string): Promise<any>
  async deriveKey(password: string, salt: string): Promise<string>
}
```

### 4. Module Registry
管理可选功能模块

```typescript
class ModuleRegistry {
  registerModule(module: Module): void
  isModuleEnabled(name: string): boolean
  getSupportedTypes(): ItemType[]
}
```

## 数据库设计

### SQLite Schema

```sql
-- 主表：存储所有同步对象
CREATE TABLE items (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL,
    created_time INTEGER NOT NULL,
    updated_time INTEGER NOT NULL,
    deleted_time INTEGER,
    payload TEXT NOT NULL,  -- JSON
    content_hash TEXT NOT NULL,
    sync_status TEXT DEFAULT 'clean',
    local_rev INTEGER DEFAULT 1,
    remote_rev TEXT,
    encryption_applied INTEGER DEFAULT 0,
    schema_version INTEGER DEFAULT 1
);

-- 索引
CREATE INDEX idx_items_type ON items(type);
CREATE INDEX idx_items_updated_time ON items(updated_time);
CREATE INDEX idx_items_sync_status ON items(sync_status);
CREATE INDEX idx_items_deleted_time ON items(deleted_time);

-- 同步状态表
CREATE TABLE sync_meta (
    key TEXT PRIMARY KEY,
    value TEXT
);

-- 全文搜索 (FTS5)
CREATE VIRTUAL TABLE items_fts USING fts5(
    id UNINDEXED,
    title,
    content,
    content='items',
    content_rowid='rowid'
);
```

## 同步机制设计

### WebDAV 目录结构
```
/workspace.json           # 工作空间元信息
/items/
  ├── note/
  │   ├── {id}.json      # 笔记对象
  │   └── ...
  ├── folder/
  │   └── {id}.json      # 文件夹对象
  └── ...
/resources/
  ├── {id}.jpg           # 附件文件
  └── ...
/changes/
  ├── changes-000001.log # 变更日志
  └── ...
/locks/
  └── lock.json          # 同步锁 (可选)
```

### 同步流程

1. **Push阶段**
   - 查询 `sync_status IN ('modified', 'deleted')`
   - 按 `updated_time` 排序上传
   - 成功后更新 `sync_status = 'clean'`

2. **Pull阶段** 
   - 读取本地 `sync_cursor`
   - 调用 `listChanges(cursor)` 获取增量
   - 下载并写入本地，处理冲突

3. **Commit阶段**
   - 更新 `sync_cursor`
   - 记录同步统计
   - 释放锁

### 冲突处理策略

**第一阶段：冲突副本**
- 检测：本地 `modified` + 远端 `remote_rev` 更新
- 处理：保留本地为冲突副本，用远端覆盖原版本
- UI：提供冲突笔记入口，用户手动合并

## 开发路线图

### 阶段 1 - MVP (4-6周)
- [x] 项目架构设计
- [ ] Electron 项目搭建
- [ ] SQLite 数据库集成
- [ ] 基础 UI 框架
- [ ] 笔记 CRUD 功能
- [ ] 文件夹管理
- [ ] 标签系统
- [ ] 本地搜索
- [ ] WebDAV 明文同步
- [ ] 冲突副本处理

### 阶段 2 - 增强功能 (3-4周)
- [ ] 定时同步
- [ ] 断点续传
- [ ] Workspace 级加密
- [ ] 自建服务器后端
- [ ] 图片附件支持
- [ ] 导出功能 (Markdown/PDF)
- [ ] 主题切换

### 阶段 3 - 扩展模块 (4-6周)
- [ ] 待办事项模块
- [ ] 思维导图模块  
- [ ] 密码库模块
- [ ] AI 助手集成
- [ ] 网址收藏
- [ ] 在线工具集
- [ ] 文件快传

### 阶段 4 - 移动端 (6-8周)
- [ ] Android 客户端开发
- [ ] 跨平台数据同步测试
- [ ] 移动端特有功能

## 技术决策

### 为什么选择 Electron？
1. **快速开发**：Web 技术栈，开发效率高
2. **跨平台**：一套代码支持 Windows/macOS/Linux  
3. **生态丰富**：npm 生态，SQLite/加密库支持好
4. **用户体验**：接近原生应用体验
5. **不考虑大小**：按需求明确说明

### 为什么统一 Item 模型？
1. **同步简化**：统一的同步逻辑，不需要为每种类型单独处理
2. **扩展性**：新增模块只需要定义 payload 结构
3. **一致性**：统一的版本控制、冲突处理、加密策略
4. **性能**：单表查询，索引优化简单

### 为什么选择冲突副本而非自动合并？
1. **数据安全**：避免自动合并导致内容丢失
2. **用户控制**：用户明确知道冲突并手动处理
3. **实现简单**：第一阶段避免复杂的 CRDT 算法
4. **稳定可靠**：减少边界情况和 bug

## 下一步行动

1. **确认技术选型**：UI 框架选择 (React + Ant Design?)
2. **项目初始化**：创建 Electron + React + TypeScript 项目
3. **数据库集成**：SQLite 连接和 Schema 创建
4. **核心模块实现**：ItemsManager 基础功能
5. **UI 原型**：笔记列表、编辑器、文件夹树

请确认这个设计方向是否符合你的预期，我们可以开始具体的实现工作！